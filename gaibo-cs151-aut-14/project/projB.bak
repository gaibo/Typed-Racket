#lang typed/racket

;; NOTICE THAT THIS PROJECT UTILIZES THE SOLUTIONS GIVEN BY THE INSTRUCTORS

(require typed/test-engine/racket-tests)

(require/typed 2htdp/image
               [#:opaque Image image?]
               [overlay (Image Image -> Image)]
               [empty-image Image]
               [circle (Real String String -> Image)]
               [square (Real String String -> Image)]
               [rectangle (Real Real String String -> Image)]
               [text (String Integer String -> Image)] 
               [beside/align (String Image * -> Image)]
               [above/align (String Image * -> Image)])

;; =============================================================================
;; ============================ Part A (Solutions) =============================

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DATA DEFINITIONS

;; game players
(define-type Player (U 'black 'white))

;; board positions
(define-struct Pos
  ([row : Integer]  ;; an integer on the interval [0,7]
   [col : Integer]) ;; an integer on the interval [0,7]
  #:transparent)

;; possible contents of a square on the board
(define-type Cell (U Player 'none))

;; game board
(define-struct Board
  ([squares : (Listof Cell)]) ;; a list of length 64
  #:transparent)

;; game state
(define-struct Game
  ([board : Board]
   [next  : Player])
  #:transparent)

;; direction
(define-struct Dir
  ([dr : (U -1 0 1)]
   [dc : (U -1 0 1)])
  #:transparent)

;; outcome of a game
(define-type Outcome (U Player 'tie))

;; maybe type
(define-type (Maybe A) (U 'Nothing (Just A)))
(define-struct (A) Just ([value : A]) #:transparent)

;; pairs
(define-struct (A B) Pair ([fst : A] [snd : B]) #:transparent)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CONSTANTS

;; index offsets for the 8-neighborhood of a square
(define neighbor-offsets
  (list (Dir -1 -1) (Dir -1 0) (Dir -1 1)
        (Dir 0 -1) (Dir 0 1)
        (Dir 1 -1) (Dir 1 0) (Dir 1 1)))

;; width of the board in squares
(define board-wid 8)

;; number of squares on the board
(define num-cells (* board-wid board-wid))

;; lower-bound on display width of a single cell
(define minimum-cell-wid 10)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; UTILITY FUNCTIONS

(: other-player : Player -> Player)
;; return the other player
(define (other-player player)
  (match player ['white 'black] ['black 'white]))

(: same-player : Player -> (Cell -> Boolean))
;; curried function for testing if a cell holds a player's piece
(define (same-player player)
  (lambda ([p : Cell]) (symbol=? player p)))

(: player->string : Player -> String)
;; return the name of the player
(define (player->string player)
  (match player ['black "Black"] ['white "White"]))

(: is-empty? : Cell -> Boolean)
;; is a cell value 'none?
(define (is-empty? cell) (symbol=? cell 'none))

(: on-board? : Pos -> Boolean)
;; is a position on the board?
(define (on-board? p)
  (match p [(Pos r c) (and (<= 0 r 7) (<= 0 c 7))]))

(: pos->index : Pos -> Integer)
;; convert a position to an index (0..63)
(define (pos->index p)
  (match p [(Pos row col) (+ (* board-wid row) col)]))

(: index->pos : Integer -> Pos)
;; convert an index to a position
(define (index->pos idx)
  (Pos (quotient idx 8) (remainder idx 8)))

(: cells-update : (Listof Cell) Integer Cell -> (Listof Cell))
;; functional update an element of a list of cells
(define (cells-update cells idx v)
  (local
    {(: update : Integer (Listof Cell) -> (Listof Cell))
     (define (update i cells)
       (match* (i cells)
         [(0 (cons hd tl)) (cons v (rest cells))]
         [(i (cons hd tl)) (cons hd (update (- i 1) tl))]
         [(_ _) (error 'cells-update "invalid index")]))}
    (update idx cells)))

(: board-update : Pos Cell Board -> Board)
;; functional update of a board
(define (board-update p v brd)
  (match brd [(Board cells) (make-Board (cells-update cells (pos->index p) v))]))

(: cell-at : Board Integer Integer -> Cell)
;; return the cell value at the given row and column
(define (cell-at brd r c)
  (match brd [(Board cells) (list-ref cells (+ (* board-wid r) c))]))

(: board-ref : Board Pos -> Cell)
;; return the cell value at the given position
(define (board-ref brd p)
  (match brd [(Board cells) (list-ref cells (pos->index p))]))

(: pos+ : Pos Dir -> Pos)
;; add a position and a direction
(define (pos+ p dir)
  (match* (p dir) [((Pos pr pc) (Dir dr dc)) (make-Pos (+ pr dr) (+ pc dc))]))

(: count-pieces : Board Player -> Integer)
;; count the pieces on the board belonging to the player
(define (count-pieces brd player)
  (foldl
   (lambda ([cell : Cell] [sum : Integer])
     (if (symbol=? cell player) (+ sum 1) sum))
   0
   (Board-squares brd)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; VISUALIZATION

(: build-row : (Integer -> Image) -> Image)
;; glue eight images left-to-right using the supplied function to create the
;; images
(define (build-row mkImg)
  (foldl
   (lambda ([img : Image] [acc : Image]) (beside/align "middle" acc img))
   empty-image
   (build-list board-wid mkImg)))

(: build-col : (Integer -> Image) -> Image)
;; glue eight imagestop-to-bottom using the supplied function to create the
;; images
(define (build-col mkImg)
  (foldl
   (lambda ([img : Image] [acc : Image]) (above/align "middle" acc img))
   empty-image
   (build-list board-wid mkImg)))

(: game-image : Game Integer -> Image)
;; render the game state as an image of the given width
(define (game-image game total-wid)
  (local
    {(define cell-wid (/ total-wid (+ board-wid 1)))
     (define font-sz (exact-floor cell-wid))
     (: text2 : String String -> Image)
     (define (text2 s1 s2) (text (string-append s1 " " s2) font-sz "Black"))}
    (if (< cell-wid minimum-cell-wid)
        (error 'game-image "total width too small")
        (match game
          [(Game brd player)
           (above/align
            "left"
            (draw-board cell-wid brd)
            (rectangle total-wid 5 "solid" "white")
            (text2 (player->string player) "is next")
            (text2 "Black's score:" (number->string (count-pieces brd 'black)))
            (text2 "White's score:" (number->string (count-pieces brd 'white))))]))))

(: board-image : Board Integer -> Image)
;; render the board state as an image of the given width
(define (board-image brd total-wid)
  (local
    {(define cell-wid (/ total-wid (+ board-wid 1)))}
    (if (< cell-wid minimum-cell-wid)
        (error 'game-image "total width too small")
        (draw-board cell-wid brd))))

(: draw-board : Real Board -> Image)
;; helper function that actually draws a board given the width of a square.
(define (draw-board cell-wid brd)
  (local
    {(define box (square cell-wid "outline" "black"))
     (define empty-sq (overlay box (square cell-wid "solid" "darkgreen")))
     (define black-sq (overlay (circle (/ (- cell-wid 6) 2) "solid" "black") empty-sq))
     (define white-sq (overlay (circle (/ (- cell-wid 6) 2) "solid" "white") empty-sq))
     (define font-sz (exact-floor (- cell-wid 4)))
     (: label-sq : Integer -> Image)
     (define (label-sq i) (overlay (text (number->string i) font-sz "black") box))
     (: cell->image : Cell -> Image)
     (define (cell->image cell)
       (match cell
         ['none empty-sq]
         ['black black-sq]
         ['white white-sq]))
     (: mk-row : Integer -> Image)
     (define (mk-row r)
       (build-row (lambda [(c : Integer)] (cell->image (cell-at brd r c)))))}
    (beside/align
      "bottom"
      (build-col label-sq)
      (above/align "middle" (build-row label-sq) (build-col mk-row)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; GAME LOGIC

;; initial state of the game board
(define new-board
  (board-update
   (make-Pos 3 4) 'black
   (board-update
    (make-Pos 4 3) 'black
    (board-update
     (make-Pos 3 3) 'white
     (board-update
      (make-Pos 4 4) 'white
      (make-Board (make-list num-cells 'none)))))))

;; initial state of the game
(define new-game (make-Game new-board 'black))

(: try-flip-in-dir : Board Player Pos Dir -> (Listof Pos))
;; given a board, player, starting position, and direction, try to flip pieces
;; We assume that the initial pos is empty and on the board
(define (try-flip-in-dir brd player start dir)
  (local
    {(define p1 (pos+ start dir))
     (define is-other? (same-player (other-player player)))
     (: try-flip : Pos (Listof Pos) -> (Listof Pos))
     ;; flip opponent's pieces in direction dir until we hit one of player's
     ;; pieces.  Return the empty list if we cannot flip legally
     (define (try-flip p ps)
       (cond
         [(not (on-board? p)) '()]
         [(is-other? (board-ref brd p)) (try-flip (pos+ p dir) (cons p ps))]
         [(is-empty? (board-ref brd p)) '()]
         [else ps]))}
    (try-flip p1 '())))

(: flips : Board Player Pos -> (Listof Pos))
;; return a list of the squares that are flipped if the player places a piece
;; at the given position.  The result does _not_ include the played piece.
;; The empty list is returned if the move is not legal.
(define (flips brd player p)
  (local
    {(: f : Dir (Listof Pos) -> (Listof Pos))
     (define (f dir cells) (append (try-flip-in-dir brd player p dir) cells))}
    (if (and (on-board? p) (is-empty? (board-ref brd p)))
        (foldl f '() neighbor-offsets)
        '())))

(: outflanks? : Board Player Pos -> Boolean)
;; return true if the player can legally place a piece on the board at
;; the given location.
(define (outflanks? brd player p)
  (local
    {(: f : Dir -> Boolean)
     (define (f dir) (cons? (try-flip-in-dir brd player p dir)))}
    (and (on-board? p)
         (is-empty? (board-ref brd p))
         (ormap f neighbor-offsets))))

(: board-apply-move : Board Player Pos -> Board)
;; apply a move to board; signal an error if the move is not legal
(define (board-apply-move brd player p)
  (match (flips brd player p)
    ['() (error 'apply-move "illegal move")]
    [ps (local
          {(: apply-flip : Pos Board -> Board)
           (define (apply-flip q brd) (board-update q player brd))}
          (foldl apply-flip brd (cons p ps)))]))

(: apply-move : Game Player Pos -> Game)
;; apply a move to a game state; signal an error if the move is not legal
(define (apply-move g player pos)
  (match g
    [(Game brd next)
     (if (symbol=? next player)
         (Game (board-apply-move brd player pos) (other-player next))
         (error 'apply-move "not your turn to move"))]))

(: move-possible? : Board Player -> Boolean)
;; is it possible for the player to move on the given board?
(define (move-possible? brd player)
  (local
    {(define cells (Board-squares brd))
     (: search : Integer -> Boolean)
     ;; search the board squares looking for an empty square where the
     ;; player can make a legal move (i.e., outflank the opponent).
     (define (search idx)
       (if (< idx num-cells)
           (or (outflanks? brd player (index->pos idx)) (search (+ idx 1)))
           #f))}
    (search 0)))

(: game-over? : Game -> Boolean)
;; is the game over?
(define (game-over? g)
  (match g
    [(Game brd _) (not (or (move-possible? brd 'white)
                           (move-possible? brd 'black)))]))

(: outcome : Game -> Outcome)
;; determine the outcome of a game
(define (outcome g)
  (local
    {(define brd (Game-board g))
     (define white-score (count-pieces brd 'white))
     (define black-score (count-pieces brd 'black))}
    (cond
      [(< white-score black-score) 'black]
      [(> white-score black-score) 'white]
      [else 'tie])))


;; =============================================================================
;; ================================== Part B ===================================

(define-type Strategy (Game -> Pos))

(: choose-always : Pos -> Strategy)
;; consumes a position, and returns a function, a Strategy, that is the
;; constant choice function for that position
(define (choose-always p)
  (lambda ([g : Game]) p))

(: choose-upper-left-always : Strategy)
;; Strategy of always choosing the upper left corner cell
(define choose-upper-left-always 
  (choose-always (Pos 0 0)))

(: first-move : Strategy)
;; return the Strategy of always choosing the first cell that is possible
(define first-move
  (lambda ([game : Game])
    (match game
      [(Game board next)
       (local
         {(: search : Integer -> Pos)
          ;; search the board squares looking for the first empty square where
          ;; the player can make a legal move (i.e., outflank the opponent).
          (define (search idx)
            (if (< idx num-cells)
                (if (outflanks? board next (index->pos idx))
                    (index->pos idx)
                    (search (+ idx 1)))
                (error "no legal moves remaining")))}
         (search 0))])))
;; TESTS
(check-expect (first-move new-game) (Pos 2 3))

(test)